apiVersion: v1
kind: ConfigMap
metadata:
  name: config-backup-config
  namespace: isa-superapp
  labels:
    app.kubernetes.io/name: config-backup
    app.kubernetes.io/instance: production
    app.kubernetes.io/component: backup
data:
  backup.sh: |
    #!/bin/bash
    set -e

    # Configuration
    BACKUP_DIR="/backup"
    TIMESTAMP=$(date +"%Y%m%d_%H%M%S")
    BACKUP_NAME="isa_config_${TIMESTAMP}"
    RETENTION_DAYS=90

    # Kubernetes namespace
    NAMESPACE="${NAMESPACE:-isa-superapp}"

    echo "Starting configuration backup: ${BACKUP_NAME}"

    # Create backup directory if it doesn't exist
    mkdir -p "${BACKUP_DIR}/${BACKUP_NAME}"

    # Backup ConfigMaps
    echo "Backing up ConfigMaps..."
    kubectl get configmaps -n "${NAMESPACE}" -o yaml > "${BACKUP_DIR}/${BACKUP_NAME}/configmaps.yaml"

    # Backup Secrets (without sensitive data - structure only)
    echo "Backing up Secrets structure..."
    kubectl get secrets -n "${NAMESPACE}" -o yaml | \
      sed 's/data:/data_backup_disabled:/g' > "${BACKUP_DIR}/${BACKUP_NAME}/secrets_structure.yaml"

    # Backup Ingress resources
    echo "Backing up Ingress resources..."
    kubectl get ingress -n "${NAMESPACE}" -o yaml > "${BACKUP_DIR}/${BACKUP_NAME}/ingress.yaml"

    # Backup Services
    echo "Backing up Services..."
    kubectl get services -n "${NAMESPACE}" -o yaml > "${BACKUP_DIR}/${BACKUP_NAME}/services.yaml"

    # Backup PersistentVolumeClaims
    echo "Backing up PVCs..."
    kubectl get pvc -n "${NAMESPACE}" -o yaml > "${BACKUP_DIR}/${BACKUP_NAME}/pvcs.yaml"

    # Backup NetworkPolicies
    echo "Backing up NetworkPolicies..."
    kubectl get networkpolicies -n "${NAMESPACE}" -o yaml > "${BACKUP_DIR}/${BACKUP_NAME}/networkpolicies.yaml"

    # Backup Helm releases (if helm is available)
    if command -v helm &> /dev/null; then
      echo "Backing up Helm releases..."
      helm list -n "${NAMESPACE}" -o yaml > "${BACKUP_DIR}/${BACKUP_NAME}/helm_releases.yaml"
    fi

    # Create compressed archive
    tar -czf "${BACKUP_DIR}/${BACKUP_NAME}.tar.gz" \
      -C "${BACKUP_DIR}" \
      "${BACKUP_NAME}"

    # Remove uncompressed backup
    rm -rf "${BACKUP_DIR}/${BACKUP_NAME}"

    # Calculate checksum
    sha256sum "${BACKUP_DIR}/${BACKUP_NAME}.tar.gz" > "${BACKUP_DIR}/${BACKUP_NAME}.sha256"

    echo "Configuration backup completed: ${BACKUP_NAME}"

    # Clean up old backups
    find "${BACKUP_DIR}" -name "isa_config_*.tar.gz" -mtime +${RETENTION_DAYS} -delete
    find "${BACKUP_DIR}" -name "isa_config_*.sha256" -mtime +${RETENTION_DAYS} -delete

    echo "Cleanup completed"

  restore.sh: |
    #!/bin/bash
    set -e

    # Configuration
    BACKUP_DIR="/backup"
    NAMESPACE="${NAMESPACE:-isa-superapp}"

    if [ -z "$1" ]; then
      echo "Usage: $0 <backup_file>"
      echo "Available backups:"
      ls -la "${BACKUP_DIR}"/isa_config_*.tar.gz
      exit 1
    fi

    BACKUP_FILE="$1"

    if [ ! -f "${BACKUP_DIR}/${BACKUP_FILE}" ]; then
      echo "Backup file not found: ${BACKUP_DIR}/${BACKUP_FILE}"
      exit 1
    fi

    echo "Starting configuration restore from: ${BACKUP_FILE}"

    # Verify checksum if available
    CHECKSUM_FILE="${BACKUP_DIR}/${BACKUP_FILE%.tar.gz}.sha256"
    if [ -f "${CHECKSUM_FILE}" ]; then
      echo "Verifying backup integrity..."
      cd "${BACKUP_DIR}" && sha256sum -c "${CHECKSUM_FILE}"
    fi

    # Extract backup
    TEMP_DIR=$(mktemp -d)
    tar -xzf "${BACKUP_DIR}/${BACKUP_FILE}" -C "${TEMP_DIR}"

    BACKUP_DIR_EXTRACTED="${TEMP_DIR}/$(basename "${BACKUP_FILE}" .tar.gz)"

    # Restore ConfigMaps
    if [ -f "${BACKUP_DIR_EXTRACTED}/configmaps.yaml" ]; then
      echo "Restoring ConfigMaps..."
      kubectl apply -f "${BACKUP_DIR_EXTRACTED}/configmaps.yaml" -n "${NAMESPACE}"
    fi

    # Note: Secrets need to be restored manually with proper data
    echo "WARNING: Secrets structure backed up, but data needs manual restoration"

    # Restore other resources
    for resource in ingress services pvcs networkpolicies; do
      if [ -f "${BACKUP_DIR_EXTRACTED}/${resource}.yaml" ]; then
        echo "Restoring ${resource}..."
        kubectl apply -f "${BACKUP_DIR_EXTRACTED}/${resource}.yaml" -n "${NAMESPACE}"
      fi
    done

    # Cleanup
    rm -rf "${TEMP_DIR}"

    echo "Configuration restore completed successfully"
    echo "Note: Secrets and sensitive data need to be restored manually"

---
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: config-backup-pvc
  namespace: isa-superapp
  labels:
    app.kubernetes.io/name: config-backup
    app.kubernetes.io/instance: production
    app.kubernetes.io/component: backup
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 10Gi
  storageClassName: gp3

---
apiVersion: batch/v1
kind: CronJob
metadata:
  name: config-backup
  namespace: isa-superapp
  labels:
    app.kubernetes.io/name: config-backup
    app.kubernetes.io/instance: production
    app.kubernetes.io/component: backup
spec:
  schedule: "0 5 * * *"  # Daily at 5 AM
  jobTemplate:
    spec:
      template:
        spec:
          serviceAccountName: config-backup-sa
          containers:
          - name: config-backup
            image: bitnami/kubectl:latest
            command:
            - /bin/bash
            - -c
            - /scripts/backup.sh
            env:
            - name: NAMESPACE
              value: "isa-superapp"
            volumeMounts:
            - name: backup-scripts
              mountPath: /scripts
            - name: backup-storage
              mountPath: /backup
            resources:
              requests:
                cpu: 100m
                memory: 256Mi
              limits:
                cpu: 500m
                memory: 512Mi
          volumes:
          - name: backup-scripts
            configMap:
              name: config-backup-config
              defaultMode: 0755
          - name: backup-storage
            persistentVolumeClaim:
              claimName: config-backup-pvc
          restartPolicy: OnFailure

---
apiVersion: v1
kind: ServiceAccount
metadata:
  name: config-backup-sa
  namespace: isa-superapp
  labels:
    app.kubernetes.io/name: config-backup
    app.kubernetes.io/instance: production
    app.kubernetes.io/component: backup

---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: config-backup-role
  labels:
    app.kubernetes.io/name: config-backup
    app.kubernetes.io/instance: production
    app.kubernetes.io/component: backup
rules:
- apiGroups: [""]
  resources: ["configmaps", "secrets", "services", "persistentvolumeclaims"]
  verbs: ["get", "list"]
- apiGroups: ["networking.k8s.io"]
  resources: ["ingresses", "networkpolicies"]
  verbs: ["get", "list"]

---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: config-backup-binding
  labels:
    app.kubernetes.io/name: config-backup
    app.kubernetes.io/instance: production
    app.kubernetes.io/component: backup
subjects:
- kind: ServiceAccount
  name: config-backup-sa
  namespace: isa-superapp
roleRef:
  kind: ClusterRole
  name: config-backup-role
  apiGroup: rbac.authorization.k8s.io